/**
 * qbuffer -- buffered binary datastream for piping, buffering and rechunking
 *
 * Copyright (C) 2015 Andras Radics
 * Licensed under the Apache License, Version 2.0
 *
 * 2015-09-15 - AR.
 */


'use strict'

var util = require('util')
var EventEmitter = require('events').EventEmitter


function QBuffer( opts ) {
    if (this === global || !this) return new QBuffer(opts)
    opts = opts || {}
    // TODO: throttle input above highWaterMark only if setDelimiter says we have a complete record waiting
    // TODO: otherwise might deadlock waiting for the paused data to finish arriving
    this.highWaterMark = opts.highWaterMark || 1024000
    this.lowWaterMark = opts.lowWaterMark || 40960
    if (opts.encoding) this.readEncoding = this.writeEncoding = opts.encoding
    this.readEncoding = opts.readEncoding || null
    this.writeEncoding = opts.writeEncoding || null
    this.start = 0
    this.length = 0
    this.chunks = new Array()
    //this.emitter = new EventEmitter()
this.emitter = this
    this._nextLine = -1

    var self = this
    this.emitter.on('pipe', function(stream) {
        self.pipeFrom(stream)
    })
    this.emitter.on('unpipe', function(stream) {
        stream.emit('_unpipeFrom')
    })

    return this
}
util.inherits(QBuffer, EventEmitter)

var QBuffer_prototype = {
    highWaterMark: null,
    lowWaterMark: null,
    encoding: undefined,
    readEncoding: undefined,
    writeEncoding: undefined,
    start: 0,
    length: 0,
    emitter: null,
    _nextLine: -1,                      // cached _lineEnd(), cleared by _skipbytes(), unget() and setDelimiter()

    chunks: null,
    _outpipe: null,                     // destination pipe used by pipeTo
    _pipeFragments: false,
    throttled: false,                   // output paused implicitly by throttling
    paused: false,                      // output paused explicitly by the user
    overfull: false,                    // buffer over capacity, asked writers to throttle
    ended: false,                       // when end() has been called

/**
    // delegated EventEmitter methods
    addListener: function addListener( ev, func ) { return this.emitter.addListener(ev, func) },
    on: function on( ev, func ) { return this.emitter.on(ev, func) },
    once: function once( ev, func ) { return this.emitter.once(ev, func) },
    removeListener: function removeListener( ev, func ) { return this.emitter.removeListener(ev, func) },
    removeAllListeners: function removeAllListeners( ev, func ) { return this.emitter.removeAllListeners(ev, func) },
    setMaxListeners: function setMaxListeners( n ) { this.emitter.setMaxListeners( n ) },
    getMaxListeners: function getMaxListeners(  ) { this.emitter.getMaxListeners(  ) },
    // FIXME: use a setter/getter to change attribute ?
    defaultMaxListeners: null,
    listeners: function listeners( ev ) { return this.emitter.listeners(ev) },
    // FIXME: we restrict arguments count to max 5
    emit: function emit( ev, a, b, c, d, e ) { return this.emitter.emit(ev, a, b, c, d, e) },
    listenerCount: function listenerCount( type ) { this.emitter.listenerCount( type ) },
**/

    setEncoding:
    function setEncoding( encoding ) {
        this.encoding = encoding
        this.setReadEncoding(encoding)
        this.setWriteEncoding(encoding)
        return this
    },

    // like Stream.setEncoding
    setReadEncoding:
    function setReadEncoding( encoding ) {
        this.readEncoding = encoding
        return this
    },

    // like Stream.setDefaultEncoding
    setWriteEncoding:
    function setWriteEncoding( encoding ) {
        this.writeEncoding = encoding
        return this
    },

    // return the end of the next record in the data, or -1 if not yet known
    _lineEnd:
    function _lineEnd( ) {
        if (this._nextLine >= 0) return this._nextLine
        return this._nextLine = this._computeLineEnd()
    },

    // locate the end of the next record in the data
    // Default records are newline terminated strings
    // this method is overridden at runtime by setDelimiter()
    _computeLineEnd:
    function _computeLineEnd( ) {
        var eol = this._indexOfCharcode(10, this.start)
        return eol === -1 ? -1 : eol + 1
    },

    _delimiterFunc: null,

    setDelimiter:
    function setDelimiter( delimiter ) {
        this._nextLine = -1
        switch (true) {
        case delimiter === null:
            // on unspecified or empty delimiter restore the default, newline terminated strings
            delete this._computeLineEnd
            break
        case typeof delimiter === 'string':
            var ch1 = delimiter.charCodeAt(0), ch2 = delimiter.charCodeAt(1)
            if (delimiter.length === 1) this._computeLineEnd = function() {
                var eol = this._indexOfCharcode(ch1, this.start)
                return eol === -1 ? -1 : eol + 1
            }
            else if (delimiter.length === 2) this._computeLineEnd = function() {
                var eol = this._indexOfCharcode(ch1, ch2, this.start)
                return eol === -1 ? -1 : eol + 2
            }
            else throw new Error("string delimiters longer than 2 chars not supported yet")
            break
        case typeof delimiter === 'function':
            var self = this
            this._delimiterFunc = delimiter
            this._computeLineEnd = function() {
                // computed record end returns a user-visible start-relative offset
                var eol = self._delimiterFunc()
                return eol === -1 ? -1 : eol + this.start
            }
            break
        case typeof delimiter === 'number':
            this._computeLineEnd = function() { return this.start + delimiter }
            break
        default:
            throw new Error("unrecognized record delimiter: " + (typeof delimiter))
            break
        }
        return this
    },

/***
    indexOf:
    function indexOf( string, start ) {
        start = this.start + (start === undefined) ? 0 : start
        var pos = this._findSubstring(string, start)
        return pos >= 0 ? pos - this.start : -1
    },
***/

    indexOfChar_simple:
    function indexOfChar( char, char2, start ) {
        var pos = (start === undefined)
            ? this._indexOfCharcode(char.charCodeAt(0), (char2 || 0) + this.start)
            : this._indexOfCharcode(char.charCodeAt(0), char2.charCodeAt(0), (start || 0) + this.start)
        return pos === -1 ? -1 : pos - this.start
    },

    indexOfChar:
    function indexOfChar( char, char2, start ) {
        //var pos = this._indexOfCharcode(char.charCodeAt(0), (start || 0) + this.start)
        var pos = this._indexOfCharcode(char.charCodeAt(0), start === undefined ? (char2 || 0) + this.start : (start || 0) + this.start)
        return pos === -1 ? -1 : pos - this.start
    },

    indexOfChar2:
    function indexOfChar2( char, char2, start ) {
        var pos = this._indexOfCharcode(char.charCodeAt(0), char2.charCodeAt(0), (start || 0) + this.start)
        return pos === -1 ? -1 : pos - this.start
    },

    // push data back onto the head of the queue
    unget:
    function unget( chunk, encoding ) {
        this._nextLine = -1
        if (this.start > 0) { this.chunks[0] = this.chunks[0].slice(this.start) ; this.start = 0 }
        if (!Buffer.isBuffer(chunk)) chunk = new Buffer(chunk, encoding || this.writeEncoding)
        this.chunks.unshift(chunk)
        this.length += chunk.length
        // TODO: what to return?
    },

    skipbytes:
    function skipbytes( nbytes ) {
        this._skipbytes(this.start + nbytes)
    },

    // retrieve the next record (newline-terminated string) form the buffer
    getline:
    function getline( ) {
        var eol = this._lineEnd()
        return (eol === -1) ? null : this.read(eol - this.start)
    },

    // return, but do not consume, the next record from the buffer
    peekline:
    function peekline( ) {
        var eol = this._lineEnd()
        return (eol === -1) ? null : this._peekbytes(eol, this.readEncoding)
    },

    // return the requested number of bytes or null if not that many, or everything in the buffer
    read:
    function read( nbytes, encoding, cb ) {
        if (!cb && typeof encoding === 'function') {
            cb = encoding
            encoding = null
        }
        // TODO: if callback provided and no data yet, queue reader and complete read later
        // TODO: actually invoke callback TBD
        encoding = encoding || this.readEncoding
        if (nbytes > this.length) return null
        if (!nbytes) nbytes = this.length

        var bound = this.start + nbytes
        var ret = this._peekbytes(bound, encoding)
        if (ret !== null) this._skipbytes(bound)
        return ret
    },

    peekbytes:
    function peekbytes( nbytes, encoding ) {
        return this._peekbytes(this.start + nbytes, encoding || this.readEncoding)
    },

    _peekbytes:
    function _peekbytes( bound, encoding ) {
        if (!this.chunks.length) return null
        var chunk = (bound <= this.chunks[0].length) ? this.chunks[0] : this._concat(bound)
        if (!chunk) return null
        return encoding ? chunk.toString(encoding, this.start, bound) : chunk.slice(this.start, bound)
    },

    // append data to the buffered contents
    write:
    function write( chunk, encoding, cb ) {
        if (!cb && typeof encoding === 'function') {
            cb = encoding
            encoding = undefined
        }
        if (this.ended) {
            var err = new Error("write after end")
            if (cb) return cb(err)
            else throw err
        }
        if (!Buffer.isBuffer(chunk)) chunk = new Buffer(chunk, encoding || this.writeEncoding)
        this.chunks.push(chunk)
        this.length += chunk.length

        if (this._outpipe) this._drain()
        if (cb) cb(null, chunk.length)

        // return true if willing to buffer more, false to throttle input
        // automatic throttling requires knowing the record boundaries! (ie setDelimiter),
        // otherwise might deadlock waiting for the paused data to finish arriving
        // only when we already have the next record for getline() can we throttle
        if (this.length > this.highWaterMark && this._lineEnd() >= 0) {
            this.overfull = true
            return false
        }
        return true
    },

    end:
    function end( chunk, encoding, cb ) {
        if (chunk !== null && chunk !== undefined && chunk !== '') this.write(chunk, encoding)
        this.ended = true
        // drain again to end() the output stream (even though the write() just did)
        this._drain()
        // FIXME: wait for output to be fully drained, then emit 'finish' and invoke callback
        // this.emitter.once('finish', cb)
    },

    pipeFrom:
    function pipeFrom( stream ) {
        var self = this
        var onData, onEnd, onClose
        stream.on('data', onData = function onData(chunk) { self.write(chunk) })
        stream.once('end', onEnd = function() { stream.emit('_unpipeFrom') })
        stream.once('close', onClose = function() { stream.emit('_unpipeFrom') })
        stream.once('_unpipeFrom', function() {
            stream.removeListener('data', onData)
            stream.removeListener('end', onEnd)
            stream.removeListener('close', onClose)
        })
    },

    unpipeFrom:
    function unpipeFrom( stream ) {
        stream.emit('_unpipeFrom')
        return this
    },

    pipeTo:
    function pipeTo( stream, options ) {
        options = options || {}
        // NOTE: this pipe() is limited to piping to only one destination
        if (this._outpipe) this._outpipe.emit('_unpipeTo')

        var self = this, onDrain, onFinish
        stream.on('drain', onDrain = function() {
            self.throttled = false
            self._drain()
        })
        stream.once('_unpipeTo', function() {
            stream.removeListener('drain', onDrain)
            stream.removeListener('drain', onFinish)
            self._outpipe = null
            self._pipeFragments = false
            self.throttled = false
        })
        if (options.end === undefined || options.end) stream.once('_pipeToEnd', function() {
            // if pipeTo options.end only then end the output stream (default true)
            stream.end()
        })
        stream.once('close', function() { stream.emit('_unpipeTo') })

        this._outpipe = stream
        this._pipeFragments = options.allowFragments || false
        this._drain()
        return stream
    },

    // flush the queued records to the receiving pipe
    // _drain() writes data, and thus can re-pause the pipe
    _drain: function _drain( ) {
        // TODO: maybe drain as an event emitter, emit 'data' records
        // TODO: not clear whether pause/resume should affect a pipe (vs just 'data' events)
        if (!this._outpipe || this.throttled || this.paused) return
        var chunk
        while ((chunk = this.getline() || this._pipeFragments && this.length && this.read(this.length))) {
            var writeMore = this._outpipe.write(chunk)
            if (writeMore === false) { this.throttled = true ; return }
        }
        if (this.length === 0 && this.ended && this._outpipe.emit) {
            // unhook from and end() the destination stream
            this._outpipe.emit('_pipeToEnd')
        }
    },

    unpipeTo:
    function unpipeTo( stream ) {
        // NOTE: this is not a full pipe(), the stream can be piped to only one destination at a time
        if (stream && stream !== this._outpipe) return
        stream = stream || this._outpipe
        stream.emit('_unpipeTo')
        return this
    },

    pause:
    function pause( ) {
        this.paused = true
        return this
    },

    resume:
    function resume( ) {
        this.paused = false
        this._drain()
        return this
    },

    // find the offset of the first char in the buffered data
    // usage: ioc(code), ioc(code, start), ioc(code, code2, start)
    _indexOfCharcode:
    function _indexOfCharcode( code, code2, start ) {
        // must be called with start >= this.start
        if (start === undefined) { start = code2; code2 = undefined }
        start = start || this.start
        var i, j, offset = 0, chunk
        for (i=0; i<this.chunks.length; i++) {
            chunk = this.chunks[i]
            if (start >= chunk.length) {
                // advance to the chunk containing start
                start -= chunk.length
                offset += chunk.length
            }
            else {
                if (code2 === undefined) {
                    for (j=start; j<chunk.length; j++) {
                        // then scan that chunk for the first instance of code
                        if (chunk[j] === code) return offset + j
                    }
                }
                else {
                    for (j=start; j<chunk.length; j++) {
                        // NOTE: testing for a second charcode slows getline() 40%, use separate loop
                        if (chunk[j] === code) {
                            if (chunk.length > j + 1 && chunk[j+1] === code2) return offset + j
                            if (chunk.length === j + 1 && this.chunks.length > i + 1 && this.chunks[i+1][0] === code2) return offset + j
                        }
                    }
                }
                // if scanned a chunk, scan the next from its very beginning
                offset += chunk.length
                start = 0
            }
        }
        return -1
    },

/***
    // find the offset of the first occurrence of the substring not before start
    _findSubstring:
    function _findSubstring( substring, start ) {
        // TODO: WRITEME
    },
***/

    // skip past and discard all buffered bytes until bound
    _skipbytes:
    function _skipbytes( bound ) {
        this._nextLine = -1
        while (this.length > 0) {
            if (bound >= this.chunks[0].length) {
                var chunk = this.chunks.shift()
                bound -= chunk.length
                this.length -= (chunk.length - this.start)
                this.start = 0
            }
            else {
                this.length -= (bound - this.start)
                this.start = bound
                if (this.start > 100000 && this.chunks[0].length - this.start < this.start) {
                    // do not let the first buffer grow without bound, trim it for the next _concat
                    this.chunks[0] = this.chunks[0].slice(this.start)
                    this.start = 0
                }
                if (this.overfull && this.length < this.lowWaterMark) { this.overfull = false }
                return
            }
        }
    },

    // merge Buffers until bound is contained inside the first buffer
    // returns the first Buffer, now larger, or null if not enough data
    _concat:
    function _concat( bound ) {
        if (this.start + this.length < bound) return null
        var chunks = this.chunks

        var len = 0, nchunks = 0
        while (len < bound) {
            len += chunks[nchunks].length
            nchunks += 1
        }

        // optimize degenerate case when first chunk already holds all the data
        if (nchunks === 1) return chunks[0]

        // replace the first nchunks chunks with their merged contents, using a temporary placeholder
        // TODO: timeit: might be faster to just shift off the chunks and copy into a preallocated Buffer
        var chunk = Buffer.concat(chunks.splice(0, nchunks, ['placeholder']))
        return chunks[0] = chunk
    }
}

for (var i in QBuffer_prototype) QBuffer.prototype[i] = QBuffer_prototype[i]
// NOTE: reads lines 2.5x faster if methods not poked singly into prototype
// so do not inherit, much faster to delegate the EventEmitter methods
// NOTE: but assigning prototype to self speeds accesses back up!
QBuffer.prototype = QBuffer.prototype

//QBuffer.prototype = QBuffer_prototype

module.exports = QBuffer
